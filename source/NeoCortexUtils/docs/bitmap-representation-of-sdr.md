# Bitmap Representation of SDRs

We have represented the generated SDRs in the form of Bitmap.
For generating bitmaps we have used a common method ```DrawBitmap()``` for all the encoders and spatial pooler.


## DrawBitmap Method

### void DrawBitmap(int[,], int, int, String, Color, Color, string)

   Draws the bitmap from arrays of active columns.

C#
```DrawBitmap(int[,] twoDimArray, int width, int height, String filePath, Color inactiveCellColor, Color activeCellColor, string text = null)```


## Parameters:

- int [] twoDimArray: array of active columns
- int width: Output width
- int height: Output height
- string filePath: the bitmap PNG filename
- Color inactiveCellColor: Color for the inactive cells
- activeCellColor: Color for the active cells
- string text: text to be written with the bitmap.


### Implementation logic

The size of the bitmap can be altered by changing the values of ```width``` and ```height```.
And the different colored bitmaps can be generated by setting ```activeCellColor``` and ```inactiveCellColor``` to different colors are desired.

Then using a parameter “scale” which is calculated using ```scale=width/w```,
(width: requested width and w: width inside of array)

the width and height are given to the bitmap (w*scale, h*scale).

After this, for the chosen indexes X, Y,
If ```twoDimArray[X, Y]==1```, then the activeCellColor is set using ```SetPixel``` function.
Otherwise, the inactiveCellColor is set for that pixel.

And then the bitmap is generated and saved in the defined folder.

## Examples

### DrawBitmap sample for DateTime Encoder
As DrawBitmap takes the above described parameters, to create the first parameter i.e., twoDimArray firstly a 1-D array is generated which is the SDR.
In our TestMethod 8, result2 contains the 1-D array.
This 1-D array is converted to a 2-D array by:

```int[,] twoDimenArray2 = ArrayUtils.Make2DArray<int>(result2, (int)Math.Sqrt(result2.Length), (int)Math.Sqrt(result2.Length));```

and then the transpose of the 2-D array (twoDimArray) is passed to the DrawBitmap method.

```var twoDimArray2 = ArrayUtils.Transpose(twoDimenArray2);
NeoCortexUtils.DrawBitmap(twoDimArray2, 1024, 1024, $"{prefix}_out_{input.ToString().Replace("/", "-").Replace(":", "-")}_32x32-N-{encoderSettings2["DayOfWeekEncoder"]["N"]}-W-{encoderSettings2["DayOfWeekEncoder"]["W"]}.png", Color.Yellow, Color.Black);
var twoDimArray2 = ArrayUtils.Transpose(twoDimenArray2);
NeoCortexUtils.DrawBitmap(twoDimArray2, 1024, 1024, $"{prefix}_out_{input.ToString().Replace("/", "-").Replace(":", "-")}_32x32-N-{encoderSettings2["DayOfWeekEncoder"]["N"]}-W-{encoderSettings2["DayOfWeekEncoder"]["W"]}.png", Color.Yellow, Color.Black);
```
For this example, N=156, so the size of 1-D array(result2) is 156, and the 2-D array is (int)Math.Sqrt(156) = 12, (int)Math.Sqrt(156)=12.

Width and height given is: 1024,1024 respectively.
Color for inactive cell is set to Yellow and for active cell is set to Black.

The generated SDR for TestMethod8 with input “05/27/2017 21:58:07” is:

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

And the generated Bitmap is:

<img src="https://user-images.githubusercontent.com/74201238/113520614-90162180-9594-11eb-83c1-3878aaa16e93.png" width="450"><br />

For this example,
scale = width /w = 1024/156 = 6
so for the SDR bit at index [Xcount,Ycount] in twoDimArray, the color is set for scale * scale (6x6=36) pixels out of 1024x1024 pixels.

### DrawBitmap sample for Scalar Encoder

To generate Bit Maps in Scalar Encoder the printBitMap function is called in the Test Method. Here we take ***TestMethod9*** in our Unit Test into account.
In case of Scalar Encoder numbers are encoded.
In ***TestMethod9*** we are encoding the Air Quality Index (AQI) to which humans are exposed to. The value of Air Quality Index varies from 0 to 500.
The data that we have used is that the quality of air that humans are exposed to 0-49 is Good; 50-149 is Moderate; 150-249 is Unhealthy for sensitive groups;
250-349 is Unhealthy; 350-449 is Very Unhealthy; 450-500 is Hazardous.

The function ***printBitMap*** is called in ***TestMethod9***. Once executed, ***printBitMap*** encodes the input and coverts it to a 1-D Array.
This output is equal to the SDR . This 1-D Array is stored in result1.
This 1-D Array is then converted to a 2-D array using

```int[,] twoDimenArray = ArrayUtils.Make2DArray<int>(result1, (int)Math.Sqrt(result1.Length), (int)Math.Sqrt(result1.Length));```

This resulting 2-D array is then transposed using

```var twoDimArray = ArrayUtils.Transpose(twoDimenArray);```

This transposed array is then passed to the ***DrawBitmap*** method

```NeoCortexUtils.DrawBitmap(twoDimArray, 1024, 1024, Path.Combine(folderName, filename), Color.Yellow, Color.DarkOrange, text: i.ToString());```

In this example, the value of N is set 20 while initializing the encoding parameters for the encoder. So, the size of SDR which is saved in result1 is 20.

As this value is then converted to 2-D Array, hence 20 is paased to the ***(int) Math.Sqrt(result1.Length)*** and ***(int) Math.Sqrt(result1.Length)***
This becomes  ***(int) Math.Sqrt(20) = 4*** and ***(int) Math.Sqrt(20) = 4***

These results are then transposed and passed to the DrawBitmap method. In this method  In this method
- Height and Width of the Bit Map is set to 1024.
- The Path to the output folder is also mentioned. The generated Bit Maps will be saved in this folder.
- An active bit in the SDR is represented by Dark Orange colour and an inactive bit is represented by Yellow colour.
- We also see the value of i for which the Bit Map is generated in the top left corner of the Bit Map.

### The generated SDRs are as follows
***For Range 0 - 49***

For input value 6: 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,

For input value 20: 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,

For input value 49: 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,


***For Range 50 - 149***

For input value 50: 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,

For input value 111: 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,

For input value 149: 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,


***For Range 150 - 249***

For input value 150: 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,

For input value 213: 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,

For input value 249: 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,


***For Range 250 - 349***

For input value 250: 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,

For input value 327: 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,

For input value 349: 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,


***For Range 350 - 449***

For input value 350: 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,

For input value 401: 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,

For input value 449: 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,


***For Range 450 - 500***

For input value 450: 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

For input value 497: 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,


## The generated Bit Maps are as follows

<img src="https://user-images.githubusercontent.com/74201238/114312695-de2aa800-9af3-11eb-926f-a0f7dbe20c41.png" width="450"><br />

In this example, ***scale = width / w***.  We have width = 1024 and w =20.
So scale =  1024 / 20 = 51

For the SDR bit at index ***[Xcount, Ycount]*** in ***twoDimArray***, the colour is set for scale * scale (51 x 51 = 2601) pixels out of 1024 x 1024 pixels.


### DrawBitmap sample for Geospatial Encoder

 ***TestMethod5***
 To generate SDRs and and create bitmap, the values of W, N, MinVal and MaxVal are set as below.

                ```encoderSettings.Add("W", 103);
                   encoderSettings.Add("N", 238);
                   encoderSettings.Add("MinVal", (double)48.75);
                   encoderSettings.Add("MaxVal", (double)51.86);```

For bitmaps in the ***printImage*** method

```for (double j = (long)encoder.MinVal; j < (long)encoder.MaxVal; j +=1)````

initialises j with minimum value 48 and iterates the loop for bitmap until j less than the maximum value 51, creating bitmap for 48, 49 and 50.


```var result2 = encoder.Encode(j);```

***result2*** array of size 238 in 1D.

```int[,] twoDimenArray = ArrayUtils.Make2DArray<int>(result2,  (int)Math.Sqrt(result2.Length), (int)Math.Sqrt(result2.Length));```

***twoDimenArray*** array in 2D (size 15*15 since Square root of 238 =15)

```var twoDimArray = ArrayUtils.Transpose(twoDimenArray); ```

***twoDimArray*** transpose of twoDimenArray (rows becomes the columns)

This ***twoDimArray*** is then passed to ***Drawbitmap*** method.
Bitmap of Height and the width 1024
Inactive cell are represted by red color and active cells black color.


```public static void DrawBitmap(int[,] twoDimArray, int width, int height, String filePath, Color inactiveCellColor, Color activeCellColor, string text = null)```

```NeoCortexUtils.DrawBitmap(twoDimArray, 1024, 1024, $"{folderName}\\{j}.png", Color.Red, Color.Green, text: j.ToString());```

For the 2D array w=15 and h=15
The w(15) and h(15) of array must be always lesser than the width(1024) and height(1024) of bitmap.

```scale = width / w (1024/15 = 68)```

If (twoDimArray[Xcount, Ycount] == 1) then Pixel is set to active cell color else it is set to inactive cell color.


The SDR’s generated with input ***48.4*** is

```
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```


The bitmaps generated are as below.

<img src="https://user-images.githubusercontent.com/74201238/114312848-68730c00-9af4-11eb-814b-f93abc095885.png" width="450"><br />

***scale = width / w***.   width = 1024 and w =15.
scale =  1024 / 15 = 68

SDR bit at index ***[Xcount, Ycount]*** in ***twoDimArray***, the colour is set for scale * scale (68 x 68 = 4624) pixels out of 1024 x 1024 pixels.


## Change in size and color of Bitmap

Ghange the above parameter as:

```W= 21, N=40  MinVal=48.75  MaxVal=51.86```

 1D array is of size 40 and 2D is of size 6*6.
The height and the width of the bitmap is 1024
W and h of 2D array is 6.

   ```Scale 1024/6 = 170```

The color of the bitmap is changed to Red for inactive cells and green for active cells.

   ```NeoCortexUtils.DrawBitmap(twoDimArray, 1024, 1024, $"{folderName}\\{j}.png", Color.Red, Color.Green, text: j.ToString());```

The SDR’s generated for input 51.85 is
```0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1```

The bitmaps generated in this case are:

<img src="https://user-images.githubusercontent.com/74201238/114312899-a2441280-9af4-11eb-8a29-c3379d280fe0.png" width="450"><br />

The bitmap generated for the same values 48, 49 and 50 when W and N is changed
W=103  - 21
N=238  - 41


## Bitmap representation of Image using Spatial Pooler


   The activeArray computed by the spatial pooler is converted to a 2-dimentional array with the help of “ArrayUtils”.
   In this case the dimensions are set to be 64x64. The 2D array can be further transposed and used as an input parameter for Bitmap function.
   SDRs generated can be represented in graphical presentation with the help of bitmaps.

```System.Drawing.Bitmap myBitmap = new System.Drawing.Bitmap(bmpWidth, bmpHeight);```
    Bitmap function can be accessible from the library “System.Drawing” which needs 2 parameters – the bitmap width and bitmap height.

```NeoCortexUtils.DrawBitmaps(arrays, outputImage, Color.Yellow, Color.Gray, OutImgSize, OutImgSize);```
    The DrawBitmaps function of the NeoCortexUtils helps to build the SDR represention. It takes 6 parameters to process the final bitmap.

## Parameter Info
- arrays:  The 2D array which contains the SDRs.
-	outputImage: The filepath where the output bitmap is to be stored.
-	Color.Yellow: Color of the inactive bit
-	Color:Grey:  Color of the active bit
-	OutImgSize: The width of the output Bitmap
-	OutImgSize: The height of the output Bitmap

The pixel values in the output bitmap are set to the respective color according to the active and inactive bits. Depending on the desired size of Bitmap to be presented,
the width and height can be chosen.

### Example representing an Alphabet L in Bitmap after computing in spatial pooler
2D array with dimension 64x64 containing the SDRs, generated from spatial pooler has to be represented in Bitmap. The dimensions of the bitmap are chosen to be 1024x1024.
Since the 2D array is of a smaller dimension to that of Bitmap, a scale is considered here so that the bitmap with dimension 1024x1024 can be fully utilized to represent
the 64x64 2D array.

```var scale = ((bmpWidth) / twoDimArrays.Count) / (w+1) ;```

In this use case, the scale is calculated to be 7 with the below values set to the variables

- var scale = (1024 / 2) / (64+1);

The count for the 2D arrays is 2 here because it represents 2 Bitmaps- one for a 64x64 SDR representation and one is 28x28 for the binarized alphabet L representation.

<img src="https://user-images.githubusercontent.com/74201563/113511808-0baaab00-9562-11eb-81ea-3ccc35eaa34d.png" width="450"><br />

With scale set to 7, for each position of 64x64 2D array is set to 49 pixel positions in the 1024x1024 bitmap.
For example, if the scale varies to 15 with the following changes in the variable values to *var scale = (1024 / 1) / (64+1)* then each position in 64x64 2D array is represented
by 225 pixel positions of 1024x1024 bitmap as below.

<img src="https://user-images.githubusercontent.com/74201563/113511852-3563d200-9562-11eb-8eb7-55ce5127983d.png" width="450"><br />

With the help of the below code snippet
```
if (arr[Xcount, Ycount] == 1)
    {
        myBitmap.SetPixel(n * (bmpWidth / twoDimArrays.Count) + Xcount * scale + padX, Ycount * scale + padY, activeCellColor);
        k++;
    }
else
    {
        myBitmap.SetPixel(n * (bmpWidth / twoDimArrays.Count) + Xcount * scale + padX, Ycount * scale + padY, inactiveCellColor);
        k++;
    }
```
For each active bit in 64x64 2D array and with the scale of 7, 49 pixel positions in 1024x1024 are set to color Grey and the rest inactive bits to yellow.
The dimensions of the bitmap to be represented can be changed by providing the values for width and height in DrawBitMap() function.

### Example representing Overlap(Intersection),Difference and Union for Alphabet L and V in Bitmap after computing in spatial pooler
General Bitmap representation of L and V:

<img src="https://user-images.githubusercontent.com/74201563/114621457-014c8780-9cad-11eb-88aa-211f8af78214.png" width="450"><br />

Below are the represenatation for Overlap, Difference and Union:

<img src="https://user-images.githubusercontent.com/74201563/114621659-42dd3280-9cad-11eb-8ff3-be63f8b7f4d2.png" width="450"><br />

Two SDRs are compared with the help of ***UnionSDRFun(), DiffSDRFun()*** and ***OverlapSDRFun()*** functions.
The overlap.png shows very few intersections as the SDRs are very different from each other. Basically, the combination of Overlap and Difference gives us Union.

### Example representing Overlap(Intersection),Difference and Union for Alphabet L and small l in Bitmap after computing in spatial pooler
General Bitmap representation of L and l:

<img src="https://user-images.githubusercontent.com/74201563/114622067-ca2aa600-9cad-11eb-9433-739543ee776f.png" width="450"><br />

Below are the represenatation for Overlap, Difference and Union:

<img src="https://user-images.githubusercontent.com/74201563/114622123-da428580-9cad-11eb-829b-d5af3aebd614.png" width="450"><br />

On comaprison between two SDRs, the overlap.png shows more  overlaps/intersections in comparison to the above example. SDRs are simlar to each other.



